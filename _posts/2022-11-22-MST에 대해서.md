---
layout: single
title: "MST(ìµœì†Œì‹ ì¥íŠ¸ë¦¬)ì— ëŒ€í•´ì„œ..."
toc: true
toc_sticky: true
toc_label: "ëª©ì°¨"
categories: algorithms, tree
excerpt: "MST(ìµœì†Œì‹ ì¥íŠ¸ë¦¬)ë€?"
tag: [algorithms, tree]
---

# ğŸ“˜ MST(ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬)ì— ëŒ€í•´ì„œ...
`MST`ë€ 'ìµœì†Œì‹ ì¥íŠ¸ë¦¬'ë¡œ, ê°€ì¥ ë¹„ìš©ì´ ì ì€ ê²½ë¡œë¡œ ì´ë£¨ì–´ì§„ íŠ¸ë¦¬ë¥¼ ë§í•œë‹¤.  
MSTë¥¼ ì•Œê¸° ì „ì— `Spanning Tree`ì¦‰, `ì‹ ì¥íŠ¸ë¦¬`ë¶€í„° ë¨¼ì € ì•Œì•„ì•¼ í•œë‹¤.

---
## 1. Spanning Tree (ì‹ ì¥íŠ¸ë¦¬)
`Spanning Tree`ë€ ê·¸ë˜í”„ ë‚´ì˜ ëª¨ë“  `vertex`ë¥¼ í¬í•¨í•˜ëŠ” íŠ¸ë¦¬ì´ë‹¤.  
- Spanning TreeëŠ” ê·¸ë˜í”„ì˜ 'ìµœì†Œ ì—°ê²° ë¶€ë¶„ ê·¸ë˜í”„'ì´ë‹¤. (ì¦‰, ê·¸ë˜í”„ì—ì„œ ì¼ë¶€ edgeë¥¼ ì„ íƒí•´ì„œ ë§Œë“  íŠ¸ë¦¬ì´ë‹¤)
    - ìµœì†Œ ì—°ê²° = `edge`ì˜ ìˆ˜ê°€ ê°€ì¥ ì ìŒ.  
    - nê°œì˜ `vertex`ë¥¼ ê°–ëŠ” ê·¸ë˜í”„ì˜ ìµœì†Œ `edge`ì˜ ìˆ˜ëŠ” `n-1`ê°œì´ë‹¤.  
    - n-1ê°œì˜ edgeë¡œ ì—°ê²°ë˜ì–´ ìˆìœ¼ë©´ ë°˜ë“œì‹œ íŠ¸ë¦¬í˜•íƒœê°€ ë˜ê³ , ì´ ê²ƒì„ `ì‹ ì¥íŠ¸ë¦¬`ë¼ê³  í•œë‹¤.  

### 1-1. Spanning Treeì˜ íŠ¹ì§•
- `DFS(ê¹Šì´ìš°ì„ íƒìƒ‰)`, `BFS(ë„ˆë¹„ìš°ì„ íƒìƒ‰)`ì„ ì´ìš©í•˜ì—¬ ê·¸ë˜í”„ì—ì„œ ì‹ ì¥íŠ¸ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ìˆë‹¤.
- í•˜ë‚˜ì˜ ê·¸ë˜í”„ì—ëŠ” ë‹¤ì–‘í•œ ì‹ ì¥íŠ¸ë¦¬ê°€ ì¡´ì¬í•  ìˆ˜ ìˆê³ , ê·¸ ì¤‘ ê°€ì¥ ì ì€ ë¹„ìš©ì˜ ì‹ ì¥íŠ¸ë¦¬ë¥¼ `MST(ìµœì†Œì‹ ì¥íŠ¸ë¦¬)`ë¼ê³  í•œë‹¤.  
- ì‹ ì¥íŠ¸ë¦¬ëŠ” íŠ¹ìˆ˜í•œ í˜•íƒœì˜ íŠ¸ë¦¬ì´ë¯€ë¡œ, ëª¨ë“  `vertex`ë“¤ì´ `connected`ë˜ì–´ ìˆì–´ì•¼ í•˜ë©°, `cycle`ì„ í˜•ì„±í•´ì„œëŠ” ì•ˆëœë‹¤.  
- nê°œì˜ vertexë¥¼ ì •í™•íˆ n-1ê°œì˜ ê°„ì„ ìœ¼ë¡œ ì—°ê²°í•œë‹¤.  

---
## 2. MST (ìµœì†Œì‹ ì¥íŠ¸ë¦¬)
`Spanning Tree` ì¤‘ì—ì„œ ì‚¬ìš©ëœ `edge`ì˜ `weight(ê°€ì¤‘ì¹˜)`ì˜ í•©ì´ ê°€ì¥ ì‘ì€ íŠ¸ë¦¬ì´ë‹¤. 
- ê·¸ë˜í”„ì— ìˆëŠ” ëª¨ë“  vertexë“¤ì„ ê°€ì¥ ì ì€ ë¹„ìš©ì˜ edgeë“¤ë¡œ ì—°ê²°í•¨

### 2-1. MSTì˜ íŠ¹ì§•
- edgeì˜ ê°€ì¤‘ì¹˜ì˜ í•©ì´ ìµœì†Œì—¬ì•¼ í•œë‹¤.  
- nê°œì˜ vertexë¥¼ ê°€ì§€ëŠ” ê·¸ë˜í”„ì— ëŒ€í•´ ë°˜ë“œì‹œ n-1ê°œì˜ ê°„ì„ ë§Œ ì‚¬ìš©í•œë‹¤.
- `cycle`ì´ ìˆì–´ì„  ì•ˆëœë‹¤.  

### 2-2. MST êµ¬í˜„ ì•Œê³ ë¦¬ì¦˜
#### 2-2-1. Kruskal Algorithm
`greedy algorithm(íƒìš• ì•Œê³ ë¦¬ì¦˜)`ì„ ì´ìš©í•˜ì—¬ ê·¸ë˜í”„ì˜ ëª¨ë“  vertexë¥¼ ìµœì†Œ ë¹„ìš©ìœ¼ë¡œ ì—°ê²°í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜  

[ê³¼ì •]
> 1. ê·¸ë˜í”„ì˜ edgeë“¤ì„ weightì˜ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬í•œë‹¤.
> 2. ì •ë ¬ëœ edgeë¦¬ìŠ¤íŠ¸ì—ì„œ ìˆœì„œëŒ€ë¡œ cycleì„ í˜•ì„±í•˜ì§€ ì•ŠëŠ” edgeë¥¼ ì„ íƒí•œë‹¤.
>       - ê°€ì¥ ë‚®ì€ ê°€ì¤‘ì¹˜ë¥¼ ë¨¼ì € ì„ íƒ
>       - cycleì„ ë§Œë“œëŠ” edgeëŠ” ì œì™¸
> 3. í•´ë‹¹ edgeë¥¼ í˜„ì¬ì˜ MSTì˜ ì§‘í•©ì— ì¶”ê°€í•œë‹¤.  

[ì˜ˆì œì½”ë“œ]
ì½”ë“œëŠ” ë‹¤ì‹œ ë‚´ê°€ ì§œë³¼ê²ë‹ˆë‹¤..
- íŒŒì´ì¬([ì¶œì²˜](https://it-garden.tistory.com/411))

```
graph = [(1,2,13), (1,3,5),(2,4,9),(3,4,15), (3,5,3), (4,5,1), (4,6,7), (5,6,2)]
graph.sort(key=lambda x: x[2]) # ê°€ì¤‘ì¹˜ë¡œ ì—£ì§€ ì •ë ¬ (vertex1, vertex2, weight)

mst = []
n = 6
p = [0]

for i in range(1, n+1):
    p.append(i) # ê° vertex ìì‹ ì´ ì§‘í•©ì´ ëŒ€í‘œ

def find(u):
    if u != p[u]:
        p[u] = find(p[u])    # ê²½ë¡œ ì••ì¶•
    return p[u]

def union(u, v):
    root1 = find(u)
    root2 = find(v)
    p[root2] = root1    # root2ê°€ root1ì˜ ë¶€ëª¨ë¡œ ì„¤ì •

edges = 0   # ì—£ì§€ ê°œìˆ˜
total_cost = 0  # ê°€ì¤‘ì¹˜ í•©

while True:
    if edges == n-1:
        break
    u, v, wt = graph.pop(0)
    if find(u) != find(v):  # uì™€ vê°€ ì„œë¡œ ë‹¤ë¥¸ ì§‘í•©ì— ì†í•´ ìˆìœ¼ë©´
        union(u, v)
        mst.append((u, v))
        total_cost += wt
        edges += 1

print("MST: ", mst)
print("MST_WEIGHT: ", total_cost)

```


- ìë°”([ì¶œì²˜](https://sskl660.tistory.com/72))

```
import java.util.Arrays;  
import java.util.Scanner;
/*
sample input(ì²« ì¤„ì˜ ì²« ìˆ«ìëŠ” ì •ì ì˜ ê°œìˆ˜, ë‘ ë²ˆì§¸ ìˆ«ìëŠ” ê°„ì„ ì˜ ê°œìˆ˜).
6 9
1 6 5
2 4 6
1 2 7
3 5 15
5 6 9
3 4 10
1 3 11
2 3 3
4 5 7
 */
public class Kruskal {
	static int V, E;
	static int[][] graph;
	// ê° ë…¸ë“œì˜ ë¶€ëª¨
	static int[] parent;
	// ìµœì¢…ì ìœ¼ë¡œ ì—°ê²°ëœ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ ì—°ê²° ë¹„ìš©.
	static int final_cost;

	public static void main(String[] args) {
		// ê·¸ë˜í”„ì˜ ì—°ê²°ìƒíƒœ(ë…¸ë“œ1, ë…¸ë“œ2, ë¹„ìš©)ë¥¼ ì´ˆê¸°í™”.
		Scanner sc = new Scanner(System.in);
		V = sc.nextInt();
		E = sc.nextInt();
		graph = new int[E][3];
		for (int i = 0; i < E; i++) {
			graph[i][0] = sc.nextInt();
			graph[i][1] = sc.nextInt();
			graph[i][2] = sc.nextInt();
		}
		parent = new int[V];
		final_cost = 0;

		// ê°„ì„  ë¹„ìš© ìˆœìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
		Arrays.sort(graph, (o1, o2) -> Integer.compare(o1[2], o2[2]));

		// makeSet
		for (int i = 0; i < V; i++) {
			parent[i] = i;
		}
		// ë‚®ì€ ë¹„ìš©ë¶€í„° í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ ì§„í–‰
		for (int i = 0; i < E; i++) {
			// ì‚¬ì´í´ì´ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê²½ìš°ì—ë§Œ ê°„ì„ ì„ ì„ íƒí•œë‹¤(ì—¬ê¸°ì„œëŠ” ìµœì¢… ë¹„ìš©ë§Œ ê³ ë ¤í•˜ë„ë¡ í•˜ê² ë‹¤).
			if (find(graph[i][0] - 1) != find(graph[i][1] - 1)) {
				System.out.println("<ì„ íƒëœ ê°„ì„ >");
				System.out.println(Arrays.toString(graph[i]));
				union(graph[i][0] - 1, graph[i][1] - 1);
				final_cost += graph[i][2];
				System.out.println("<ê° ë…¸ë“œê°€ ê°€ë¦¬í‚¤ê³  ìˆëŠ” ë¶€ëª¨>");
				System.out.println(Arrays.toString(parent) + "\n");
				continue;
			}
		}
		
		System.out.println("ìµœì¢… ë¹„ìš© : " + final_cost);
		sc.close();
	}

	private static void union(int a, int b) {
		a = find(a);
		b = find(b);
		if (a > b) {
			parent[a] = b;
		} else {
			parent[b] = a;
		}
	}

	private static int find(int x) {
		if (parent[x] == x)
			return x;
		else
			return find(parent[x]);
	}
}

```

#### 2-2-2. Prim Algorithm