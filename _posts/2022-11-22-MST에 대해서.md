---
layout: single
title: "MST(ìµœì†Œì‹ ì¥íŠ¸ë¦¬)ì— ëŒ€í•´ì„œ..."
toc: true
toc_sticky: true
toc_label: "ëª©ì°¨"
categories: algorithms
excerpt: "MST(ìµœì†Œì‹ ì¥íŠ¸ë¦¬)ë€?"
tag: [algorithms, tree]
---

# ğŸ“˜ MST(ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬)ì— ëŒ€í•´ì„œ...
`MST`ë€ 'ìµœì†Œì‹ ì¥íŠ¸ë¦¬'ë¡œ, ê°€ì¥ ë¹„ìš©ì´ ì ì€ ê²½ë¡œë¡œ ì´ë£¨ì–´ì§„ íŠ¸ë¦¬ë¥¼ ë§í•œë‹¤.  
MSTë¥¼ ì•Œê¸° ì „ì— `Spanning Tree`ì¦‰, `ì‹ ì¥íŠ¸ë¦¬`ë¶€í„° ë¨¼ì € ì•Œì•„ì•¼ í•œë‹¤.

---
## 1. Spanning Tree (ì‹ ì¥íŠ¸ë¦¬)
`Spanning Tree`ë€ ê·¸ë˜í”„ ë‚´ì˜ ëª¨ë“  `vertex`ë¥¼ í¬í•¨í•˜ëŠ” íŠ¸ë¦¬ì´ë‹¤.  
- Spanning TreeëŠ” ê·¸ë˜í”„ì˜ 'ìµœì†Œ ì—°ê²° ë¶€ë¶„ ê·¸ë˜í”„'ì´ë‹¤. (ì¦‰, ê·¸ë˜í”„ì—ì„œ ì¼ë¶€ edgeë¥¼ ì„ íƒí•´ì„œ ë§Œë“  íŠ¸ë¦¬ì´ë‹¤)
    - ìµœì†Œ ì—°ê²° = `edge`ì˜ ìˆ˜ê°€ ê°€ì¥ ì ìŒ.  
    - nê°œì˜ `vertex`ë¥¼ ê°–ëŠ” ê·¸ë˜í”„ì˜ ìµœì†Œ `edge`ì˜ ìˆ˜ëŠ” `n-1`ê°œì´ë‹¤.  
    - n-1ê°œì˜ edgeë¡œ ì—°ê²°ë˜ì–´ ìˆìœ¼ë©´ ë°˜ë“œì‹œ íŠ¸ë¦¬í˜•íƒœê°€ ë˜ê³ , ì´ ê²ƒì„ `ì‹ ì¥íŠ¸ë¦¬`ë¼ê³  í•œë‹¤.  

### 1-1. Spanning Treeì˜ íŠ¹ì§•
- `DFS(ê¹Šì´ìš°ì„ íƒìƒ‰)`, `BFS(ë„ˆë¹„ìš°ì„ íƒìƒ‰)`ì„ ì´ìš©í•˜ì—¬ ê·¸ë˜í”„ì—ì„œ ì‹ ì¥íŠ¸ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ìˆë‹¤.
- í•˜ë‚˜ì˜ ê·¸ë˜í”„ì—ëŠ” ë‹¤ì–‘í•œ ì‹ ì¥íŠ¸ë¦¬ê°€ ì¡´ì¬í•  ìˆ˜ ìˆê³ , ê·¸ ì¤‘ ê°€ì¥ ì ì€ ë¹„ìš©ì˜ ì‹ ì¥íŠ¸ë¦¬ë¥¼ `MST(ìµœì†Œì‹ ì¥íŠ¸ë¦¬)`ë¼ê³  í•œë‹¤.  
- ì‹ ì¥íŠ¸ë¦¬ëŠ” íŠ¹ìˆ˜í•œ í˜•íƒœì˜ íŠ¸ë¦¬ì´ë¯€ë¡œ, ëª¨ë“  `vertex`ë“¤ì´ `connected`ë˜ì–´ ìˆì–´ì•¼ í•˜ë©°, `cycle`ì„ í˜•ì„±í•´ì„œëŠ” ì•ˆëœë‹¤.  
- nê°œì˜ vertexë¥¼ ì •í™•íˆ n-1ê°œì˜ ê°„ì„ ìœ¼ë¡œ ì—°ê²°í•œë‹¤.  

---
## 2. MST (ìµœì†Œì‹ ì¥íŠ¸ë¦¬)
`Spanning Tree` ì¤‘ì—ì„œ ì‚¬ìš©ëœ `edge`ì˜ `weight(ê°€ì¤‘ì¹˜)`ì˜ í•©ì´ ê°€ì¥ ì‘ì€ íŠ¸ë¦¬ì´ë‹¤. 
- ê·¸ë˜í”„ì— ìˆëŠ” ëª¨ë“  vertexë“¤ì„ ê°€ì¥ ì ì€ ë¹„ìš©ì˜ edgeë“¤ë¡œ ì—°ê²°í•¨

[ì˜ˆì‹œ]
![image](https://user-images.githubusercontent.com/104587537/205436955-17831e82-5f1a-4b31-aa6b-0cc0bd502373.png){: width="300" height="300"}  


### 2-1. MSTì˜ íŠ¹ì§•
- edgeì˜ ê°€ì¤‘ì¹˜ì˜ í•©ì´ ìµœì†Œì—¬ì•¼ í•œë‹¤.  
- nê°œì˜ vertexë¥¼ ê°€ì§€ëŠ” ê·¸ë˜í”„ì— ëŒ€í•´ ë°˜ë“œì‹œ n-1ê°œì˜ ê°„ì„ ë§Œ ì‚¬ìš©í•œë‹¤.
- `cycle`ì´ ìˆì–´ì„  ì•ˆëœë‹¤.  
- ê·¸ë˜í”„ Gì˜ MST Të¥¼ ì°¾ì•˜ë‹¤ê³  í•´ì„œ, ê·¸ íŠ¸ë¦¬ê°€ ìœ ì¼í•œ MSTê°€ ì•„ë‹ ìˆ˜ ìˆë‹¤. ì¦‰, ë‹¤ë¥¸ MST T'ì´ ì¡´ì¬í•  ìˆ˜ ìˆë‹¤.  

### 2-2. MSTì˜ í™•ì¥

``` 
T : Gì˜ MST, AëŠ” Tì˜ subtreeë¼ê³  í•˜ì.  
Aì™€ V-Aë¥¼ ì—°ê²°í•˜ëŠ” edge(u,v)ë¥¼ `light edge`ë¼ê³  í–ˆì„ ë•Œ, edge(u,v)ëŠ” MST-Tì— ì¢…ì†ëœë‹¤.  
```

[ê³¼ì •]  
edge(u,v)ê°€ ë¹„ìš©ì´ ê°€ì¥ ì ì€ edgeì´ë©´, V-Aì—ì„œ ë…¸ë“œ(v)ë¥¼ Aë¡œ ê°€ì ¸ì˜¨ë‹¤. ì´ ê³¼ì •ì„ ë°˜ë³µí•˜ë©´ MSTë¥¼ êµ¬í•  ìˆ˜ ìˆë‹¤.  

`safe edge`ë€ "ë¹„ìš©(cost)ê°€ ê°€ì¥ ì €ë ´í•˜ë©´ì„œ cycleì„ í˜•ì„±í•˜ì§€ ì•ŠëŠ” edge"ë¥¼ ë§í•œë‹¤.   
- S : vertex ì „ì²´ì˜ ì§‘í•©
- V : ì „ì²´ ê·¸ë˜í”„ ì§‘í•©
- A : ì „ì²´ edge ì§‘í•©
- Cut : ê·¸ë˜í”„ë¥¼ Partitionìœ¼ë¡œ ë‚˜ëˆ„ëŠ”ë° ì‚¬ìš©ëœë‹¤.  
	- ì˜ˆ) Sì™€ V-Sì˜ íŒŒí‹°ì…˜ìœ¼ë¡œ ë¶„ë¦¬
- Cross : edge(u,v)ì—ì„œ uì™€ vëŠ” ê°ê° ë‹¤ë¥¸ íŒŒí‹°ì…˜ì— ì¡´ì¬í•˜ê³ , ì´ë¥¼ ì—°ê²°í•˜ëŠ” edgeë¥¼ `cross`ë¼ê³  í•œë‹¤.  
- Respect : ì–´ë–¤ edge-setì—ì„œ cutì„ ê±´ë„ˆê°€ì§€ ì•ŠëŠ” ê²½ìš°
- Light edge : cross-edge ì¤‘ ê°€ì¥ ì‘ì€ edgeì´ë‹¤.  

![image](https://user-images.githubusercontent.com/104587537/205437341-843b2a48-fc47-440c-9417-d64e04922e2b.png){: width="300" height="300"}  

### 2-3. MST êµ¬í˜„ ì•Œê³ ë¦¬ì¦˜
#### 2-3-1. Generic-MST ì˜ì‚¬ì½”ë“œ
![image](https://user-images.githubusercontent.com/104587537/205437017-562f0f96-2ac1-4a8a-956d-510ab4769db2.png){: width="300" height="300"}    

#### 2-3-2. Kruskal Algorithm (í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜)
`Kruskal Algorithm`ì´ë€ `greedy algorithm(íƒìš• ì•Œê³ ë¦¬ì¦˜)`ì„ ì´ìš©í•˜ì—¬ ê·¸ë˜í”„ì˜ ëª¨ë“  vertexë¥¼ ìµœì†Œ ë¹„ìš©ìœ¼ë¡œ ì—°ê²°í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ë‹¤.  
ì¦‰, ë¹„ìš©ì´ ê°€ì¥ ì‹¼ edgeë¥¼ ì„ íƒí•´ íŠ¸ë¦¬ë¥¼ ë§Œë“¤ì–´ ë‚˜ê°€ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ë‹¤.  

- greedy algorithm : ë¯¸ë˜ë¥¼ ìƒê°í•˜ì§€ ì•Šê³  ê° ë‹¨ê³„ì—ì„œ ê°€ì¥ ìµœì„ ì˜ ì„ íƒì„ í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ (ìì‹ ì˜ ì„ íƒì´ ìµœì„ ì˜ ì„ íƒì´ê¸¸ ë°”ë¼ëŠ” ì•Œê³ ë¦¬ì¦˜)  

[ê³¼ì •]
> 1. ê·¸ë˜í”„ì˜ edgeë“¤ì„ weightì˜ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬í•œë‹¤.
> 2. ì •ë ¬ëœ edgeë¦¬ìŠ¤íŠ¸ì—ì„œ ìˆœì„œëŒ€ë¡œ cycleì„ í˜•ì„±í•˜ì§€ ì•ŠëŠ” edgeë¥¼ ì„ íƒí•œë‹¤.
>       - ê°€ì¥ ë‚®ì€ ê°€ì¤‘ì¹˜ë¥¼ ë¨¼ì € ì„ íƒ
>       - cycleì„ ë§Œë“œëŠ” edgeëŠ” ì œì™¸
> 3. í•´ë‹¹ edgeë¥¼ í˜„ì¬ì˜ MSTì˜ ì§‘í•©ì— ì¶”ê°€í•œë‹¤.  

[ì˜ì‚¬ì½”ë“œ]  
![image](https://user-images.githubusercontent.com/104587537/205440321-1f252381-7b6e-4339-9759-d410ff670c03.png){: width="300" height="300"}  

[ì˜ˆì œì½”ë“œ]
ì½”ë“œëŠ” ë‹¤ì‹œ ë‚´ê°€ ì§œë³¼ê²ë‹ˆë‹¤..
- íŒŒì´ì¬([ì¶œì²˜](https://8iggy.tistory.com/160))

```
from collections import deque
 
 
def mst():
    def upward(buf, idx):
        parent = mst_nodes[idx]
        if parent < 0:
            return idx
        buf.append(idx)
        return upward(buf, parent)
 
    def find(idx):
        buf = []
        result = upward(buf, idx)
        for i in buf:
            mst_nodes[i] = result
        return result
 
    def union(x, y):
        x, y = find(x), find(y)
        if x == y:
            return False
        if mst_nodes[x] < mst_nodes[y]:
            mst_nodes[y] = x
        elif mst_nodes[x] > mst_nodes[y]:
            mst_nodes[x] = y
        else:
            mst_nodes[x] -= 1
            mst_nodes[y] = x
        return True
 
    V, E = 6, 9
    edges = [[1, 2, 6], [1, 3, 3], [2, 3, 2], [2, 4, 5],
             [3, 4, 3], [3, 5, 4], [4, 5, 2], [4, 6, 3], [5, 6, 5]]
    edges.sort(key=lambda x: x[2])
    mst_graph = [[0] * V for _ in range(V)]
    mst_nodes = [-1 for _ in range(V)]
    mst = []
    cost = 0
    q = deque(edges)
    while True:
        u, v, w = q.popleft()
        udx, vdx = u - 1, v - 1
        if union(udx, vdx) is False:
            continue
        mst.append((u, v))
        mst_graph[udx][vdx] = 1
        mst_graph[vdx][udx] = 1
        cost += w
        if len(mst) == V - 1:
            break
    print(f'mst cost is {cost}')
    print(mst)
    for row in mst_graph:
        print(*row)
 
 
mst()

```


- ìë°”([ì¶œì²˜](https://sskl660.tistory.com/72))

```
import java.util.Arrays;  
import java.util.Scanner;
/*
sample input(ì²« ì¤„ì˜ ì²« ìˆ«ìëŠ” ì •ì ì˜ ê°œìˆ˜, ë‘ ë²ˆì§¸ ìˆ«ìëŠ” ê°„ì„ ì˜ ê°œìˆ˜).
6 9
1 6 5
2 4 6
1 2 7
3 5 15
5 6 9
3 4 10
1 3 11
2 3 3
4 5 7
 */
public class Kruskal {
	static int V, E;
	static int[][] graph;
	// ê° ë…¸ë“œì˜ ë¶€ëª¨
	static int[] parent;
	// ìµœì¢…ì ìœ¼ë¡œ ì—°ê²°ëœ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ ì—°ê²° ë¹„ìš©.
	static int final_cost;

	public static void main(String[] args) {
		// ê·¸ë˜í”„ì˜ ì—°ê²°ìƒíƒœ(ë…¸ë“œ1, ë…¸ë“œ2, ë¹„ìš©)ë¥¼ ì´ˆê¸°í™”.
		Scanner sc = new Scanner(System.in);
		V = sc.nextInt();
		E = sc.nextInt();
		graph = new int[E][3];
		for (int i = 0; i < E; i++) {
			graph[i][0] = sc.nextInt();
			graph[i][1] = sc.nextInt();
			graph[i][2] = sc.nextInt();
		}
		parent = new int[V];
		final_cost = 0;

		// ê°„ì„  ë¹„ìš© ìˆœìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
		Arrays.sort(graph, (o1, o2) -> Integer.compare(o1[2], o2[2]));

		// makeSet
		for (int i = 0; i < V; i++) {
			parent[i] = i;
		}
		// ë‚®ì€ ë¹„ìš©ë¶€í„° í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ ì§„í–‰
		for (int i = 0; i < E; i++) {
			// ì‚¬ì´í´ì´ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê²½ìš°ì—ë§Œ ê°„ì„ ì„ ì„ íƒí•œë‹¤(ì—¬ê¸°ì„œëŠ” ìµœì¢… ë¹„ìš©ë§Œ ê³ ë ¤í•˜ë„ë¡ í•˜ê² ë‹¤).
			if (find(graph[i][0] - 1) != find(graph[i][1] - 1)) {
				System.out.println("<ì„ íƒëœ ê°„ì„ >");
				System.out.println(Arrays.toString(graph[i]));
				union(graph[i][0] - 1, graph[i][1] - 1);
				final_cost += graph[i][2];
				System.out.println("<ê° ë…¸ë“œê°€ ê°€ë¦¬í‚¤ê³  ìˆëŠ” ë¶€ëª¨>");
				System.out.println(Arrays.toString(parent) + "\n");
				continue;
			}
		}
		
		System.out.println("ìµœì¢… ë¹„ìš© : " + final_cost);
		sc.close();
	}

	private static void union(int a, int b) {
		a = find(a);
		b = find(b);
		if (a > b) {
			parent[a] = b;
		} else {
			parent[b] = a;
		}
	}

	private static int find(int x) {
		if (parent[x] == x)
			return x;
		else
			return find(parent[x]);
	}
}

```

#### 2-3-3. Prim Algorithm (í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜)
`Prim Algorithm`ì´ë€ ì‹œì‘ ë…¸ë“œì—ì„œ ë…¸ë“œë¥¼ ì¶”ê°€í•´ê°€ë©° ë‹¨ê³„ì ìœ¼ë¡œ íŠ¸ë¦¬ë¥¼ í™•ì¥í•´ë‚˜ê°€ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ë‹¤.  

[ì˜ì‚¬ì½”ë“œ]  
![image](https://user-images.githubusercontent.com/104587537/205440291-cac05311-db6e-4e8a-b0ca-2bd41e88ac33.png){: width="300" height="300"}  
  


[ì˜ˆì œì½”ë“œ]

```
from collections import defaultdict
import heapq
 
def mst():
    V, E = 6, 9
    edges = [[1, 2, 6], [1, 3, 3], [2, 3, 2], [2, 4, 5],
             [3, 4, 3], [3, 5, 4], [4, 5, 2], [4, 6, 3], [5, 6, 5]]
    graph = defaultdict(list)
    for srt, dst, weight in edges:
        graph[srt].append((dst, weight))
        graph[dst].append((srt, weight))
    mst_graph = [[0] * V for _ in range(V)]
    mst_nodes = [-1 for _ in range(V)]
    visited = [True for _ in range(V)]
    q = [(0, 1, 1)]
    while q:
        cost, node, prev = heapq.heappop(q)
        if visited[node - 1] is False:
            continue
        visited[node - 1] = False
        mst_graph[node - 1][prev - 1] = 1
        mst_graph[prev - 1][node - 1] = 1
        mst_nodes[node - 1] = cost
        for dst, weight in graph[node]:
            if visited[dst - 1] is True:
                heapq.heappush(q, (weight, dst, node))
    print(f'MST cost is {sum(mst_nodes)}')
    mst_graph[0][0] = 1
    for row in mst_graph:
        print(*row)
 
mst()

```

#### 2-3-4. ë‘ ì•Œê³ ë¦¬ì¦˜ì˜ ì‹œê°„ë³µì¡ë„ ë¹„êµ
`Kruskal Algorithm`ì˜ ì‹œê°„ë³µì¡ë„ : O(eloge)  
`Prim Algorithm`ì˜ ì‹œê°„ë³µì¡ë„ : O(n^2)  

[ë¹„êµ]
ê·¸ë˜í”„ì— edgeê°€ ì ì€ ê·¸ë˜í”„ì¸ `í¬ì†Œê·¸ë˜í”„(Sparse Graph)`ì¸ ê²½ìš°ì—ëŠ” `Kruskal Aogorithm`ì´ ìœ ë¦¬í•˜ë‹¤.  
ê·¸ë˜í”„ì— edgeê°€ ë§ì€ ê·¸ë˜í”„ì¸ `ë°€ì§‘ ê·¸ë˜í”„(Dense Graph)`ì¸ ê²½ìš°ì—ëŠ” `Prim Algorithm`ì´ ìœ ë¦¬í•˜ë‹¤.  