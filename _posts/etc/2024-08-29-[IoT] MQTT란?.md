---
layout: single
title: "📘[IoT] MQTT란?"
toc: true
toc_sticky: true
toc_label: "목차"
categories: etc
excerpt: ""
tag: [MQTT, IoT]
---

# [aws] MQTT란?

[`MQTT`](https://aws.amazon.com/ko/what-is/mqtt/)는 머신 대 머신 통신에 사용되는 `표준 기반 메시징 프로토콜` 또는 규칙 세트이다.

스마트 센서, 웨어러블 및 기타 사물 인터넷(IoT) 디바이스는 일반적으로 리소스 제약이 있는 네트워크를 통해 제한된 대역폭으로 데이터를 전송하고 수신해야 한다.

이러한 IoT 디바이스는 MQTT를 데이터 전송에 사용하는데, 구현이 쉽고 IoT 데이터를 효율적으로 전달할 수 있기 때문이다.

MQTT는 디바이스에서 클라우드로, 클라우드에서 디바이스로의 메시징을 지원한다.

> 즉, MQTT는 발행/구독(Publish/Subscribe) 기반의 메시지 송수신 프로토콜.
> 

## MQTT 프로토콜이 중요한 이유?

### 가볍고 효율적

MQTT를 IoT 디바이스에 구현할 때는 최소한의 리소스가 필요하다.

따라서 작은 마이크로컨트롤러에도 사용될 수 있다.

예시로, MQTT 제어 메시지는 2바이트만큼 작기 때문에 MQTT 메시지 헤더도 작아, 네트워크 대역폭을 최적화할 수 있다.

### 확장성

MQTT구현에는 최소량의 코드가 필요하며, 작업 시 아주 작은 전력만 소비한다.

또한 많은 수의 IoT 디바이스와의 통신을 지원하기 위한 기본적인 기능을 갖추고 있다.

### 신뢰성

많은 IoT 디바이스는 대역폭은 낮고 지연 시간은 긴 신뢰할 수 없는 셀룰러 네트워크를 통해 연결한다.

MQTT에는 IoT 디바이스에서 클라우드에 다시 연결하는 데 소요되는 시간을 줄여주는 기능이 기본적으로 탑재되어 있다..!

또한 `최대 1회(0)`, `최소 1회(1)` 및 `정확히 1회(2)`라는 3가지 서비스 품질 수준을 정의하여 IoT 사용 사례에 필요한 신뢰성을 보장한다.

- 0: `최대 1회 전송`
    - `Topic`을 통해 메시지를 전송할 뿐 보장하지는 않음 (보낸 다음 잊어버림)
- 1: `최소 1회 전송`
    - 구독하는 클라이언트가 메시지를 받았는지 불확실하면 정해진 횟수만큼 재전송함
    - 메시지의 핸드셰이킹 과정을 엄밀하게 추적하지는 않아, 중복의 위험이 있음 (확인 응답을 거치는 전달임)
- 2: `정확히 1회 전송`
    - 구독하는 클라이언트가 요구된 메시지를 정확히 한 번 수신할 수 있도록 보장함 (보장된 전달)
    - `TCP/IP` 데이터 전송의 처리에 영향을 주지 않고, MQTT 송수신자 간에만 사용됨
    - 메시지는 글자 수 제한이 없어 `긴 메시지` 혹은 `JSON` , 파일도 전송이 가능함
    - 0에 가까울 수록 메시지 처리에 대한 부하가 줄어들고, 손실의 위험이 높아짐
    - 2에 가까울 수록 메시지 손실 위험은 줄어들지만, 메시지 처리 부하가 급격히 높아짐
    - 0 ~ 1 정도의 `QoS`를 사용하며 메시지 손실의 위험은 상위 애플리케이션 차원에서 관리하는 방법이 널리 쓰이는 중임

> ❓ Topic
메시지를 발행-구독하는 행위는 채널 단위로 일어나는데, 이를 토픽이라고 한다.
토픽은 `/` 로 구분되는 계층 구조를 갖는다.
단, 최상위 토픽은 `/`로 시작하면 안되며, 토픽의 이름에는 공백이 없는 아스키코드여야 한다.
> 

### 보안

개발자는 MQTT를 사용하면 메시지를 손쉽게 암호화하고 `OAuth`, `TLS1.3`, `고객 관리형 인증서` 및 `기타 최신 인증 프로토콜`을 사용하여 디바이스와 사용자를 인증할 수 있다.

### 우수한 지원

Python과 같은 다수의 언어가 MQTT 프로토콜 구현을 광범위하게 지원한다.

따라서 개발자는 모든 유형의 애플리케이션에서 최소한의 코드 작업으로 빠르게 이 프로토콜을 구현할 수 있다.

## MQTT의 원리?

MQTT 프로토콜은 `게시/구독 모델`의 원칙을 기반으로 작동한다.

전통적인 네트워크 통신에서는 클라이언트와 서버가 서로 직접 통신하는데, 클라이언트가 서버의 리소스 또는 데이터를 요청하면 서버가 이를 처리한 후 응답을 다시 보낸다.

하지만 `MQTT`는 `게시/구독` 패턴을 사용하여 `메시지 발신자(게시자)`와 `메시지 수신자(구독자)` 를 분리한다.

대신 `메시지 브로커`가 게시자와 구독자 간의 통신을 처리한다.

`메시지 브로커`는 게시자로부터 수신되는 모든 메시지를 `필터링`하고, 구독자에게 직접 `배포`하는 것이다.

*브로커는 게시자와 구독자를 어떻게 분리할까?*

### 공간 분리

게시자와 구독자는 서로의 네트워크 위치를 모르며, IP 주소 또는 포트 번호와 같은 정보를 교환하지 않는다.

### 시간 분리

게시자와 구독자는 동시에 실행되거나 네트워크를 통해 연결되지 않는다.

### 동기화 분리

게시자와 구독자는 서로를 중단시키지 않고 메시지를 전송하거나 수신할 수 있다. (구독자는 게시자의 발신을 기다릴 필요 없음)

## MQTT의 구성 요소

MQTT는 아래와 같이 클라이언트와 브로커를 정의하여 `게시/구독` 모델을 구현한다.

### MQTT 클라이언트

MQTT 클라이언트는 서버로부터 MQTT 라이브러리를 실행하는 `마이크로컨트롤러`에 이르는 모든 디바이스가 될 수 있다.

클라이언트는 메시지를 보내는 경우 게시자 역할을, 메시지를 수신하는 경우 수신자 역할을 한다.

기본적으로 네트워크를 통해 `MQTT`를 사용하여 통신하는 모든 디바이스를 `MQTT 클라이언트 디바이스`라고 할 수 있다.

### MQTT 브로커

MQTT 브로커는 여러 클라이언트 간의 메시지를 조정하는 백엔드 시스템이다.

브로커는 `메시지 수신` 및 `필터링`, 각 메시지를 구독하는 `클라이언트 식별`, `메시지 전송` 등과 같은 작업을 담당한다.

다음과 같은 태스크 또한 처리한다.

- MQTT 클라이언트 권한 부여 및 인증
- 추가 분석을 위해 다른 시스템으로 메시지 전달
- 누락된 메시지 및 클라이언트 세션 처리

### MQTT 연결

클라이언트와 브로커는 `MQTT` 연결을 사용하여 통신을 시작한다.

클라이언트는 *CONNECT* 메시지를 **MQTT 브로커로 보내 연결을 시작한다.

브로커는 *CONNACK* 메시지로 응답하여 연결이 설정되었음을 확인한다.

MQTT 클라이언트와 브로커는 모두 `TCP/IP` 스택이 있어야 통신할 수 있다.

또한, 클라이언트는 서로 연결되지 않으며 브로커에만 연결한다.

## MQTT는 어떤 방식으로 작동할까?

다음은 MQTT의 작동 방식에 대한 개요이다.

- MQTT 클라이언트가 MQTT 브로커와의 연결을 설정함
- 연결되면 클라이언트에서 메시지를 게시하거나 특정 메시지를 구독하거나 둘 다 수행 가능
- MQTT 브로커는 메시지를 수신한 후 메시지에 관심이 있는 구독자에게 메시지를 전달함

### MQTT 주제

`주제` 는 MQTT 브로커가 MQTT 클라이언트를 위한 메시지를 필터링할 때 사용하는 키워드이다.

`주제`는 파일 또는 폴더 디렉터리와 유사한 계층 구조로 정렬된다.

### MQTT 게시

MQTT 클라이언트는 주제 및 데이터가 바이트 형식으로 포함된 메시지를 게시한다.

클라이언트는 `텍스트 데이터`, `바이너리 데이터`, `XML` 또는 `JSON` 과 같은 데이터 형식을 결정한다.

### MQTT 구독

MQTT 클라이언트는 MQTT 브로커에 *SUBSCRIBE* 메시지를 보내 관심 주제에 대한 메시지를 수신한다.

이 메시지에는 구독의 고유 식별자와 목록이 포함된다.

## MQTT over WSS 란?

`MQTT over WebSockers(WSS)`란 데이터를 웹 브라우저로 직접 수신하는 MQTT 구현이다.

이 MQTT 프로토콜은 JavaScript 클라이언트를 정의하여 브라우저에 대한 `WSS` 지원을 제공한다.

이 경우 프로토콜은 평상시와 같이 작동하지만, MQTT 메시지에 `추가 헤더`를 삽입하여 `WSS 프로토콜`도 지원한다.

*MQTT 페이로드가 WSS 봉투로 포장되었다고 생각하면 된다.*

## MQTT 는 안전한가?

MQTT 통신은 `SSL 프로토콜`을 사용하여 IoT 디바이스에서 전송되는 민감한 데이터를 보호한다.

`SSL 인증서`와 `암호`를 사용하여 클라이언트와 브로커 간에 `ID, 인증 및 권한 부여` 를 구현할 수 있다.

*어떻게 클라이언트를 인증할까?*

- 클라이언트 인증
    - MQTT 브로커는 일반적으로 `암호`와 각 클라이언트에 할당되는 `고유 클라이언트 식별자`를 사용하여 클라이언트를 인증한다.
- 서버 인증
    - 대부분의 구현에서 클라이언트 `인증서` 또는 `DNS 조회`를 통해 서버를 인증한다.

## MQTT는 RESTful인가?

> **MQTT는 RESTful이 아니다!**
> 
- REST
    - 네트워크 통신에 대한 아키텍처 접근 방식으로, 메시지 발신자와 수신자 간의 `요청-응답 패턴` 통신을 사용한다.
- MQTT
    - 애플리케이션 계층에서 `게시/구독 모델` 통신을 사용한다.
    - 메시지를 푸시 방식으로 전송하기 위한 `고정된 TCP` 연결이 필요하다.
    - `MQTT ver.5`는 REST와 유사한 방식으로 작용하는 새로운 `요청/응답` 메서드를 추가한다,
        - 여기서 게시자는 특수한 응답 주제를 첨부할 수 있고, 수신자는 이를 처리하여 적절한 응답을 생성한다.

# 결론

`MQTT` 는 국제 표준화 된 게시-구독(Publish-Subscribe) 기반의 메시지 송수신 프로토콜이다.

`작은 코드 공간`이 필요하거나 `네트워크 대역폭이 제한되는 원격 통신` 또는 `IoT와 같이 제한적`이거나 `대규모 트래픽` 전송의 경우를 위한 프로토콜인 것이다.

`TCP/IP` 프로토콜 위에서 동작하지만, 동시에 `굉장히 가벼우며`, 많은 `통신 제약들을 해결`해준다.

하지만, 메시지가 가벼운 만큼 `메시지 유형`이나 `QoS(서비스 품질)`에는 제약이 생길 수 있다.

# 참고 자료

[MQTT란 무엇인가요? - MQTT 프로토콜 설명 - AWS](https://aws.amazon.com/ko/what-is/mqtt/)

[[통신 이론] MQTT, MQTT Protocol (MQTT 프로토콜) 이란? - 1 (이론편)](https://underflow101.tistory.com/22)